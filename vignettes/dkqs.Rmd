---
title: 'linearprog: An R Package for Inference in Linear and Quadratic Programs'
author: ''
output:
  html_document:
    keep_md: yes
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
    df_print: paged
  md_document:
    toc: yes
    df_print: paged  
  github_document:
    keep_html: yes
    toc: yes
    df_print: paged
bibliography: refs.bib
vignette: |
  %\VignetteIndexEntry{dkqs} 
  %\VignetteEncoding{UTF-8} 
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE
)
```

```{r setup, include = FALSE}
require(linearprog)
require(data.table)
require(pander)
require(gurobi)
require(knitr)
require(kableExtra)
require(Momocs)
```

## Introduction
This package conducts inference on econometrics problems that can be 
studied by linear and quadratic programming using the 
cone-tightening procedure of @dkqs2018.

## Scope of the Vignette
This vignette is intended as a guide to use the `linearprog` package. Readers
may refer to section 4.2 of @dkqs2018 for details about the cone-tightening 
procedure and the supplemental appendix of @kamat2019.

## Installation and Requirements
`linearprog` can be installed from our GitHub repository via

```{r eval = FALSE}
devtools::install_github("conroylau/linearprog")
```

To use `linearprog`, one of the following packages for solving linear and
quadratic programs is required. There are four options for the solver:

1. Gurobi and the R package `gurobi` --- Gurobi can be downloaded from
[Gurobi Optimization](https://www.gurobi.com/). A Gurobi software license is 
required, which can be obtained at no cost for academic researchers. The 
instructions for installing `gurobi` on R can be found 
[here](https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html#r-package-installation).

1. IBM ILOG CPLEX Optimization Studio (CPLEX) and one of the R packages below 
--- CPLEX can be downloaded from 
[IBM](https://www.ibm.com/analytics/cplex-optimizer). A CPLEX software license
is required, which can be obtained at no cost for academic researchers. There 
are two open-source and free R packages that uses CPLEX, and users are free to
choose one of them. In addition, both packages have to be installed on the 
command line to link the package to the correct CPLEX library. The two packages' 
name and installation instrutions are as follows:
   i.  `Rcplex`  --- the instructions to install the R package can be found
   [here](https://cran.r-project.org/web/packages/Rcplex/INSTALL).
   
   i. `cplexAPI` --- the instructions to install the R package can be found
   [here](https://cran.r-project.org/web/packages/cplexAPI/INSTALL).

1. `limSolve` --- a free and open-source package available on CRAN. This can be
installed directly via the `install.packages` command in R.


If no package is specified, one of the above packages will be automatically 
chosen from those that are available.

## Usage Demonstration 1: Missing Data Problem
### Background and Data {#data}
One application of this `linearprog` package is to study the classical missing 
data problem due to @manski1989, where the sharp bounds for the identified 
set of the expected value of the observed value can be constructed by
linear and quadratic programming.

As an illustration, the dataset below studies the missing data problem and 
contains 1,000 simulated data with 2 columns. This dataset is included in
the `linearprog` package. 

```{r, drawData-df}
library(linearprog)
knitr::kable(head(sampledata, n = 10))
```
where

* `Y` is a multivariate discrete outcome variable that takes value from 0 to 1 
with step size 0.1.
* `D` is a binary treatment where *Y*~*i*~ is observed for *D*~*i*~ = 1 and 
not observed for *D*~*i*~ = 0.

### Specifying the Functions {#functions}

To conduct the tests in this `linearprog` package, users need to specify the
functions to generate the observed value of beta from the dataset. This package
provides the flexibility for users to specify their own function to generate
the value of observed value of beta. The requirement for the function provided 
by the user is as follows:

* The function's only argument is the dataset.
* The function only returns a numeric vector that corresponds to the vector for 
the observed beta. 

#### Full Information Approach

The following is an example of defining the function for the full information
approach:

```{r, syntax1}
func_full_info <- function(df){
  beta = NULL
  y_list = sort(unique(df[,"Y"]))
  n = dim(df)[1]
  yn = length(y_list)
  for (i in 1:yn){
    beta_i = sum((df[,"Y"] == y_list[i]) * (df[,"D"] == 1))/n
    beta = c(beta,c(beta_i))
  }
  beta = as.matrix(beta)
  return(beta)
}
```
The `func_full_info` function returns a vector of length that is equal to the
number of distinct observations for *Y* where element *i* of the vector refers 
to the probability that the corresponding value of *y*~*i*~ is observed.

#### Two Moments Approach

The following is an example of defining the function for the two moments 
approach:

```{r, syntax2}
func_two_moment <- function(df){
  beta = matrix(c(0,0), nrow = 2)
  n = dim(df)[1]
  beta[1] = sum(df[,"Y"] * df[,"D"])/n
  beta[2] = sum(df[,"D"])/n
  return(beta)
}
```
The `func_two_moment` function returns a vector with two elements that 
corresponds to the two moments **E**[*Y*~*i*~] and **E**[*Y*~*i*~*D*~*i*~].

### Specifying the Parameters
To conduct the inference in this package, the matrices `A_obs` and `A_tgt` have 
to be defined in order to use the function. To construct the two matrices, the
following parameters are needed:
```{r, results='markdown'}
N = dim(sampledata)[1]
J1 = length(unique(sampledata[,"Y"]))
yp = seq(0,1,1/(J1-1))
```

With the above quantities, the following matrices can be defined as follows:
```{r, results='markdown'}
A_obs_twom = matrix(c(rep(0,J1), yp, rep(0,J1), rep(1, J1)), nrow = 2,
                byrow = TRUE)
A_target = matrix(c(yp, yp), nrow = 1)
```
The matrix `A_obs_twom` refers to the observed matrix for the two moments 
approach. If users would prefer using the full information approach, the 
following matrix that correspond to the full information approach has to be
defined:
```{r, results='markdown'}
A_obs_full = cbind(matrix(rep(0,J1*J1), nrow = J1), diag(1, J1))
```

Lastly, the value of tau can be defined freely by the user as long as the
quadratic program is feasible. Here, we choose the value of tau based on the 
formula from page 15 of the supplemental appendix of @kamat2019:
```{r, results='markdown'}
tau = sqrt(log(N)/N)
```

### Calculating *p*-value

The command for applying the cone-tightening procedure in `linearprog` is 
called `dkqs_cone`. It takes the data, parameters and the function that can
calculate the observed value of beta and returns the *p*-value.

#### Syntax  {#syntax}
This `dkqs_cone` command has the following syntax:
```{r, syntax, eval = FALSE}
dkqs_cone(df = sampledata, 
          A_obs = A_obs_twom, 
          A_tgt = A_target, 
          func_obs = func_two_moment, 
          beta_tgt = 0.375, 
          bs_seed = 1,
          bs_num = 100,
          p_sig = 2,
          tau_input = tau,
          solver = gurobi,
          noisy = TRUE)
```
where

* `df` refers to the data being used in the inference.
* `A_obs` refers to the "observed matrix" in the inference.
* `A_tgt` refers to the "target matrix" in the inference.
* `func_obs` refers to the function that generates the vector of observed beta.
* `beta_tgt` refers to the value of beta to be tested.
* `bs_seed` refers to the starting value of the seed in bootstrap.
* `bs_num` refers to the total number of bootstraps to be conducted.
* `p_sig` refers to the number of decimal places in the *p*-value.
* `tau_input` refers to the value of tau chosen by the user.
* `solver` refers to the name of the solver used to solve the linear and 
quadratic programs.
* `noisy` refers to the boolean variable for whether the result messages should
be displayed in the procedure of calculating the *p*-value.

#### Output {#output}
The followings are the output when the **two moments approach** is used with 
the `gurobi` solver to test the hypothesis that `beta_tgt` is 0.375.

```{r, syntax.eval.twom, eval = TRUE}
dkqs_cone(df = sampledata, 
         A_obs = A_obs_twom, 
         A_tgt = A_target, 
         func_obs = func_two_moment, 
         beta_tgt = 0.375, 
         bs_seed = 1,
         bs_num = 100,
         p_sig = 3,
         tau_input = tau,
         solver = "gurobi",
         noisy = TRUE)
```

Alternatively, the followings are the output when the **full information
approach** is used with the `gurobi` solver to test the hypothesis that 
`beta_tgt` is 0.375.

```{r, syntax.eval.full, eval = TRUE}
dkqs_cone(df = sampledata, 
         A_obs = A_obs_full, 
         A_tgt = A_target, 
         func_obs = func_full_info, 
         beta_tgt = 0.375, 
         bs_seed = 1,
         bs_num = 100,
         p_sig = 3,
         tau_input = tau,
         solver = "gurobi",
         noisy = TRUE)
```

The results from the two approach should give the same *p*-value while the 
test statistic will be different as different moments are considered in the
problem.

### Constructing Confidence Intervals 

The command for constructing the two-sided confidence interval for a
statistical test in the `linearprog` packge is called `qpci`. The confidence 
interval is constructed by evaluating the *p*-value of a test and applying the 
biscetion method.

#### Syntax {#qpci_syntax}
The syntax of the `qpci` function is as follows:

```{r, qpci_syntax, eval = FALSE}
qpci(f = dkqs_cone, 
     farg = dkqs_farg, 
     alpha = .05, 
     lb0 = NULL, 
     lb1 = NULL, 
     ub0 = NULL, 
     ub1 = NULL, 
     tol = .0001, 
     max_iter = 20, 
     df_ci = NULL,
     noisy = TRUE)
```
where 

* `f` refers to the function that represents a testing procedure.
* `farg` refers to the list of arguments to be passed to the function of 
testing procedure.
* `alpha` refers to the signifance level of the test.
* `lb0` refers to the logical lower bound for the confidence interval.
* `lb1` refers to the maximum possible lower bound for the confidence interval.
* `ub0` refers to the logical upper bound for the confidence interval.
* `ub1` refers to the minimum possible upper bound for the confidence interval.
* `tol` refers to the tolerance level in the bisection method.
* `max_iter` refers to the maximum number of iterations in the bisection 
method.
* `df_ci` refers to dataframe that consists of the points and the corresponding
*p*-values that have been tested in constructing the confidence intervals. 
* `noisy` refers to the boolean variable for whether the result messages should
be displayed in the procedure of constructing confidence interval. 

#### Specifying the Argument
To use the `qpci` function, the arguments for the function of the test 
statistic has to be specified and passed to `farg`. For instance, if the test 
`dkqs_cone` is used, then the arguments can be defined as follows:

```{r, qprc_dkqs_farg, eval = TRUE}
dkqs_farg = list(df = sampledata,
                 A_obs = A_obs_full,
                 A_tgt = A_target,
                 func_obs = func_full_info,
                 bs_seed = 1,
                 bs_num = 100,
                 p_sig = 2,
                 tau_input = tau,
                 solver = "gurobi",
                 noisy = FALSE)
```

Note that the argument for the target value of beta, i.e. the value to be 
tested under the null, is not required in the above argument assignment.

#### Specifying the Data Frame `df_ci`
If the *p*-values at certain points have already been evaluated, users can
store them in a data frame and pass it to the function `qpci`. The 
requirement for the data frame is as follows:

* The data frame can only has two columns. The first column is `point` (which
contains the values of betas that has been evaluated) and the second column is
`value` (which corresponds to the *p*-values being evaluated).
* The data frame can only contain numeric values.

#### Output

The following shows a sample output of the function `qpci` that is used to 
the confidence interval for the test `dkqs_cone` with significance level 0.05.

```{r, eval = TRUE}
qpci(f = dkqs_cone, 
     farg = dkqs_farg, 
     alpha = 0.05, 
     lb0 = 0, 
     lb1 = 0.4, 
     ub0 = 1, 
     ub1 = 0.6, 
     tol = 0.001, 
     max_iter = 10, 
     df_ci = NULL, 
     noisy = TRUE)
```

### Constructing Multiple Confidence Intervals

The `many_qpci` function is a wrapper for the `qpci` function where the user 
can pass multiple values of alpha so multiple confidence intervals can be 
constructed in one command. 

#### Syntax
The syntax for the `many_qpci` function is as follows:

```{r, many_qpci_syntax, eval = FALSE}
many_qpci(f = dkqs_cone, 
          farg = dkqs_farg, 
          alphas = c(.01, .05), 
          lb0 = NULL, 
          lb1 = NULL, 
          ub0 = NULL, 
          ub1 = NULL, 
          tol = .0001, 
          max_iter = 20, 
          df_ci = NULL,
          noisy_one = TRUE,
          noisy_many = TRUE)
```
where 

* `alphas` refers to the list of significance levels to be used in constructing
the confidence intervals.
* `noisy_one` refers to the boolean variable for whether the result messages 
should be displayed in running the function `qpci`.
* `noisy_many` refers to the boolean variable for whether the result messages 
should be displayed in running the function `many_qpci`.
* The rest of the arguments are the same as the function `qpci` and they can 
be found [here](#qpci_syntax).

#### Output

The following shows a sample output of the function `qpci_many` that is used to 
the confidence intervals for the test `dkqs_cone` with significance level 
0.01, 0.02, 0.05 and 0.1.

```{r, eval = TRUE}
many_qpci(f = dkqs_cone, 
          farg = dkqs_farg, 
          alphas = c(0.01, 0.02, 0.05, 0.1), 
          lb0 = 0, 
          lb1 = .4, 
          ub0 = 1, 
          ub1 = .6, 
          tol = .001, 
          max_iter = 10, 
          df_ci = NULL, 
          noisy_one = FALSE, 
          noisy_many = TRUE)
```

## Help, Feature Requests and Bug Reports
Please post an issue on the 
[GitHub repository](https://github.com/conroylau/linearprog/issues).

## References



 