---
title: 'linearprog: An R Package for Inference in Linear and Quadratic Programs'
author: ''
output:
  html_document:
    keep_md: yes
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
    df_print: paged
  md_document:
    toc: yes
    df_print: paged  
  github_document:
    keep_html: yes
    toc: yes
    df_print: paged
bibliography: refs.bib
vignette: |
  %\VignetteIndexEntry{dkqs} 
  %\VignetteEncoding{UTF-8} 
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE
)
```

```{r setup, include = FALSE}
require(linearprog)
require(data.table)
require(pander)
require(gurobi)
require(knitr)
require(kableExtra)
require(Momocs)
```

## Introduction
This package conducts inference on econometrics problems that can be 
studied by linear and quadratic programming. This package uses the 
cone-tightening procedure of @dkqs2018.

## Scope of the Vignette
This vignette is intended as a guide to use the `linearprog` package. Readers
may refer to section 4.2 of @dkqs2018 for details about the cone-tightening 
procedure and the supplemental appendix of @kamat2019.

## Installation and Requirements
`linearprog` can be installed from our GitHub repository via

```{r eval = FALSE}
devtools::install_github("conroylau/linearprog")
```

To use `linearprog`, one of the following packages for solving linear and
quadratic programs is required. There are four options for the solver:

1. Gurobi and the R package `gurobi` --- Gurobi can be downloaded from
[Gurobi Optimization](https://www.gurobi.com/). A Gurobi software license is 
required, which can be obtained at no cost for academic researchers. The 
instructions for installing `gurobi` on R can be found 
[here](https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html#r-package-installation).

1. IBM ILOG CPLEX Optimization Studio (CPLEX) and one of the R packages below 
--- CPLEX can be downloaded from 
[IBM](https://www.ibm.com/analytics/cplex-optimizer). A CPLEX software license
is required, which can be obtained at no cost for academic researchers. There 
are two open-source and free R packages that uses CPLEX, and users are free to
choose one of them. In addition, both packages have to be installed on the 
command line to link the package to the correct CPLEX library. The two packages' 
name and installation instrutions are as follows:
   i.  `Rcplex`  --- the instructions to install the R package can be found
   [here](https://cran.r-project.org/web/packages/Rcplex/INSTALL).
   
   i. `cplexAPI` --- the instructions to install the R package can be found
   [here](https://cran.r-project.org/web/packages/cplexAPI/INSTALL).

1. `limSolve` --- a free and open-source package available on CRAN. This can be
installed directly via the `install.packages` command in R.


If no package is specified, one of the above packages will be automatically 
chosen from those that are available.

## Usage Demonstration 1: Missing Data Problem
### Background and Data {#data}
One application of this `linearprog` package is to study the classical missing 
data problem due to @manski1989, where the sharp bounds for the identified 
set of the expected value of the observed value can be constructed by
linear and quadratic programming.

As an illustration, the dataset below studies the missing data problem and 
contains 1,000 simulated data with 2 columns. This dataset is included in
the `linearprog` package. 

```{r, drawData-df}
library(linearprog)
knitr::kable(head(sampledata, n = 10))
```
The two variables that are used are as follows:

* `Y` is a multivariate discrete outcome variable that takes value from 0 to 1 
with step size 0.1.
* `D` is a binary treatment where *Y*~*i*~ is observed for *D*~*i*~ = 1 and 
not observed for *D*~*i*~ = 0.

### Syntax  {#syntax}
The main command for applying the cone-tightening procedure in `linearprog` is 
called `dkqs_cone`. This command has the following syntax:
```{r, syntax, eval = FALSE}
library(linearprog)
dkqs_cone(df = sampledata, 
          A_obs = A_obs_twom, 
          A_tgt = A_target, 
          func_obs = func_two_moment, 
          beta_tgt = 0.375, 
          bs_seed = 1,
          bs_num = 100,
          p_sig = 2,
          tau_input = tau,
          solver = gurobi)
```
where

* `df` refers to the data being used in the inference.
* `A_obs` refers to the "observed matrix" in the inference.
* `A_tgt` refers to the "target matrix" in the inference.
* `func_obs` refers to the function that generates the vector of observed beta.
* `beta_tgt` refers to the value of beta to be tested.
* `bs_seed` refers to the starting value of the seed in bootstrap.
* `bs_num` refers to the total number of bootstraps to be conducted.
* `p_sig` refers to the number of decimal places in the *p*-value.
* `tau_input` refers to the value of tau chosen by the user.
* `solver` refers to the name of the solver used to solve the linear and 
quadratic programs.

The following two sections explain how the functions and the required 
parameters can be constructed in order to apply the `dkqs_cone` function.

### Specifying the Functions {#functions}

The `dkqs_cone` function provides flexibility for users to specify the 
functions to generate the observed value of beta from the dataset. The 
requirement for the function provided by the user is as follows:

* The function's only argument is the dataset.
* The function only returns a numeric vector that corresponds to the vector for 
the observed beta. 

#### Full Information Approach

The following is an example of defining the function for the full information
approach:

```{r, syntax1}
func_full_info <- function(df){
  beta = NULL
  y_list = sort(unique(df[,"Y"]))
  n = dim(df)[1]
  yn = length(y_list)
  for (i in 1:yn){
    beta_i = sum((df[,"Y"] == y_list[i]) * (df[,"D"] == 1))/n
    beta = c(beta,c(beta_i))
  }
  beta = as.matrix(beta)
  return(beta)
}
```
The `func_full_info` function returns a vector of length *J* + 1 where element 
*i* of the vector refers to the probability that the corresponding value of 
*y*~*i*~ is observed.

#### Two Moments Approach

The following is an example of defining the function for the two moments 
approach:

```{r, syntax2}
func_two_moment <- function(df){
  beta = matrix(c(0,0), nrow = 2)
  n = dim(df)[1]
  beta[1] = sum(df[,"Y"] * df[,"D"])/n
  beta[2] = sum(df[,"D"])/n
  return(beta)
}
```
The `func_two_moment` function returns a vector with two elements that 
corresponds to the two moments **E**[*Y*~*i*~] and **E**[*Y*~*i*~*D*~*i*~].

### Specifying the parameters
As shown in the syntax section, the matrices `A_obs` and `A_tgt` have to be 
defined in order to use the function. To construct the two matrices, the
following parameters are needed:
```{r, results='markdown'}
N = dim(sampledata)[1]
J1 = length(unique(sampledata[,"Y"]))
yp = seq(0,1,1/(J1-1))
```

With the above quantities, the following matrices can be defined as follows:
```{r, results='markdown'}
A_obs_twom = matrix(c(rep(0,J1), yp, rep(0,J1), rep(1, J1)), nrow = 2,
                byrow = TRUE)
A_target = matrix(c(yp, yp), nrow = 1)
```
The matrix `A_obs_twom` refers to the observed matrix for the two moments 
approach. If users would prefer using the full information approach, the 
following matrix that correspond to the full information approach has to be
defined:
```{r, results='markdown'}
A_obs_full = cbind(matrix(rep(0,J1*J1), nrow = J1), diag(1, J1))
```

Lastly, the value of tau can be defined freely by the user as long as the
quadratic program is feasible. Here, we choose the value of tau based on the 
formula from page 15 of the supplemental appendix of @kamat2019:
```{r, results='markdown'}
tau = sqrt(log(N)/N)
```

### Output {#output}
The followings are the output when the two moments approach is used with the
`gurobi` solver to test the hypothesis that `beta_tgt` is 0.375.

```{r, syntax.eval.twom, eval = TRUE}
library(linearprog)
dkqs_cone(df = sampledata, 
         A_obs = A_obs_twom, 
         A_tgt = A_target, 
         func_obs = func_two_moment, 
         beta_tgt = 0.375, 
         bs_seed = 1,
         bs_num = 100,
         p_sig = 3,
         tau_input = tau,
         solver = "gurobi")
```

Alternatively, the followings are the output when the full information
approach is used with the `gurobi` solver to test the hypothesis that 
`beta_tgt` is 0.375.

```{r, syntax.eval.full, eval = TRUE}
library(linearprog)
dkqs_cone(df = sampledata, 
         A_obs = A_obs_full, 
         A_tgt = A_target, 
         func_obs = func_full_info, 
         beta_tgt = 0.375, 
         bs_seed = 1,
         bs_num = 100,
         p_sig = 3,
         tau_input = tau,
         solver = "gurobi")
```

The results from the two approach should give the same *p*-value while the 
test statistic will be different as different moments are considered in the
problem.

## Help, Feature Requests and Bug Reports
Please post an issue on the 
[GitHub repository](https://github.com/conroylau/linearprog/issues).

## References



 