% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fsst.R
\name{fsst}
\alias{fsst}
\title{Conducts inference using the FSST procedure}
\usage{
fsst(
  data = NULL,
  lpmodel,
  beta.tgt,
  R = 100,
  Rmulti = 1.25,
  lambda = NA,
  rho = 1e-04,
  n = NULL,
  weight.matrix = "diag",
  solver = NULL,
  progress = TRUE,
  sqrtm.method = function(m) pracma::sqrtm(m)$B,
  sqrtm.tol = .Machine$double.eps^(1/2),
  previous.output = NA
)
}
\arguments{
\item{data}{An \code{data frame} or a \code{matrix}.}

\item{lpmodel}{The \code{lpmodel} object.}

\item{beta.tgt}{The value to be tested.}

\item{R}{The number of bootstrap replications.}

\item{Rmulti}{The multiplier for the number of bootstrap replications. The
product of \code{Rmulti} and \code{R} refers to the maximum
number of bootstrap replications to be conducted if there are errors.}

\item{lambda}{Parameter used to obtain the restricted estimator
\eqn{\widehat{\bm{\beta}}^r_n}. A data-driven parameter \code{lambda} can
be included if \code{NA} is included as part of the vector for
\code{lambda}. For instance, if \code{lambda} is set as \code{c(0.1, NA)},
then both 0.1 and the data-driven \code{lambda} will be applied in the
\code{\link[lpinfer]{fsst}} test. The default is to use the
data-driven \code{lambda}.}

\item{rho}{Parameter used in the studentization of matrices.}

\item{n}{The sample size. This is only required if \code{data} is omitted
in the input.}

\item{weight.matrix}{The option used in the weighting matrix. There are
three options available:
\itemize{
  \item{\code{identity} --- identity matrix}
  \item{\code{diag} --- the diagonal matrix that takes the diagonal
     elements of the inverse of the variance matrix}
  \item{\code{avar} --- inverse of the variance matrix}
}}

\item{solver}{The name of the linear and quadratic programming solver that
is used to obtain the solution to linear and quadratic programs.
The solvers supported by this package are \code{cplexAPI}, \code{gurobi},
\code{limSolve} and \code{Rcplex}.}

\item{progress}{The boolean variable for whether the progress bars should
be displayed. If it is set as \code{TRUE}, the progress bars will be
displayed while the code is running.}

\item{sqrtm.method}{The method used to obtain the matrix square root in 
the \code{\link[lpinfer]{fsst}} procedure. This has to be a function that 
takes one argument that accepts a square matrix of size k x k and returns 
a square matrix of size k x k, where k can be the length of the 
\eqn{\beta(P)} vector, or the \code{beta.obs} component of the 
\code{lpinfer} object.}

\item{sqrtm.tol}{The absolute tolerance used to check whether the matrix 
square root is correct. This is done by checking whether the Frobenius 
norm is smaller than the tolerance level, i.e., when \eqn{A} is the 
give matrix, \eqn{B} is the matrix square root obtained from the
given \code{sqrtm.method} function, and \eqn{\epsilon} is the 
tolerance level, the FSST test checks whether 
\eqn{||A - BB||_F < \epsilon}. If this does not hold, the FSST test will
use the \code{\link[expm]{sqrtm}} function from the \code{expm} package
to obtain the matrix square root.}

\item{previous.output}{The list of outputs obtained from the previous
evaluation of the procedure. This is only used in the
\code{\link[lpinfer]{fsst}} test and when \code{previous.out} contains
the studentized matrix \code{omega.i}. The rest of the arguments 
are ignored.}
}
\value{
Returns the following information:
  \item{pval}{A table of \eqn{p}-values.}
  \item{cv.table}{A table of sample and bootstrap Cone and Range test
    statistics.}
  \item{call}{The matched call.}
  \item{range}{The sample range test statistic.}
  \item{cone}{The sample cone test statistic.}
  \item{test}{The sample test statistic.}
  \item{cone.n.list}{The list of bootstrap cone test statistics.}
  \item{range.n.list}{The list of bootstrap range test statistics.}
  \item{solver.name}{Name of the solver used.}
  \item{rho}{The value of \code{rho} provided by the uer..}
  \item{rhobar.i}{The regularization parameter used for the Cone
    studentization matrix.}
  \item{lambda.data}{The value of the data-driven \code{lambda} (if
    applicable).}
  \item{var.method}{The method used in obtaining the asymptotic variance
    of \code{beta.obs}.}
  \item{test.logical}{An indicator variable for whether the computation has
    been conducted. If \code{test.logical} is 1, it refers to the case
    where \code{beta.tgt} is inside the logical bound. If
    \code{test.logical} is 0, it refers to the case where
    \code{beta.tgt} is outside the logical bound.}
  \item{logical.lb}{Logical lower bound.}
  \item{logical.ub}{Logical upper bound.}
  \item{df.error}{A table showing the id of the bootstrap replication(s)
    with error(s) and the corresponding error message(s).}
  \item{R.succ}{The number of successful bootstrap replications.}
}
\description{
This module conducts inference in linear programs using the
  procedure by Fang, Santos, Shaikh and Torgovitsky (2020).
}
\details{
The following components are required in the \code{lpmodel} for the
   \code{\link[lpinfer]{fsst}} procedure:
   \itemize{
     \item{\code{A.tgt}}
     \item{\code{A.obs}}
     \item{\code{A.shp}}
     \item{\code{beta.obs}}
     \item{\code{beta.shp}}
   }
}
\examples{
## ========================================================================= ##
##
##  Example for the fsst function
##
##  This followings illustrate how the function can be used to compute
##  p-values using the missing data problem.
##
## ========================================================================= ##
rm(list = ls())

# ---------------- #
# Part 1: Load required packages
# ---------------- #
library(lpinfer)
library(future)

# ---------------- #
# Part 2: Data and lpmodel preparation
# ---------------- #
source("./inst/example/dgp_missingdata.R")
J <- 5
N <- 1000
data <- missingdata_draw(J = J, n = N, seed = 1, prob.obs = .5)
lpmodel.full <- missingdata_lpm(J = J, info = "full", data = data)
lpmodel.twom <- missingdata_lpm(J = J, info = "mean", data = data)

tau <- sqrt(log(N)/N)
beta.tgt <- .2
lambda <- .5
rho <- 1e-4
reps <- 100

# ---------------- #
# Part 3: Run the fsst procedure
# ---------------- #
# Example 1 - Using full information approach and gurobi solver (1 core)
set.seed(1)
plan(multisession, workers = 1)
fsst.full1 <- fsst(data = sampledata,
                   lpmodel = lpmodel.full,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = lambda,
                   rho = 1e-4,
                   n = nrow(sampledata),
                   weight.matrix = "identity",
                   solver = "gurobi",
                   progress = TRUE)

# Example 2 - Using two moments approach and gurobi solver (1 core)
set.seed(1)
plan(multisession, workers = 1)
fsst.twom1 <- fsst(data = sampledata,
                   lpmodel = lpmodel.twom,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = lambda,
                   rho = 1e-4,
                   n = nrow(sampledata),
                   weight.matrix = "identity",
                   solver = "gurobi",
                   progress = TRUE)

# Example 3 - Using two moments approach and gurobi solver (1 core) with
# weight.matrix = "diag"
set.seed(1)
plan(multisession, workers = 1)
fsst.twom2 <- fsst(data = sampledata,
                   lpmodel = lpmodel.twom,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = lambda,
                   rho = 1e-4,
                   n = nrow(sampledata),
                   weight.matrix = "diag",
                   solver = "gurobi",
                   progress = TRUE)

# Example 4 - Using two moments approach and gurobi solver (1 core) with
# weight.matrix = "avar"
set.seed(1)
plan(multisession, workers = 1)
fsst.twom3 <- fsst(data = sampledata,
                   lpmodel = lpmodel.twom,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = lambda,
                   rho = 1e-4,
                   n = nrow(sampledata),
                   weight.matrix = "avar",
                   solver = "gurobi",
                   progress = TRUE)

# Example 5 - Using full information approach and gurobi solver (1 core)
# with multiple lambdas
set.seed(1)
fsst.full2 <- fsst(data = sampledata,
                   lpmodel = lpmodel.full,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = c(.1, .2, .5),
                   rho = rho,
                   n = nrow(sampledata),
                   weight.matrix = "identity",
                   solver = "gurobi",
                   progress = TRUE)

# Example 6 - Using full information approach and gurobi solver (1 core)
# with data-driven lambda
set.seed(1)
fsst.full3 <- fsst(data = sampledata,
                   lpmodel = lpmodel.full,
                   beta.tgt = beta.tgt,
                   R = reps,
                   lambda = NA,
                   rho = rho,
                   n = nrow(sampledata),
                   weight.matrix = "identity",
                   solver = "gurobi",
                   progress = TRUE)
}
